# The performance problem

Performance is currently limited by the following pattern:

* Fetch the global doc
* Say "oh hey, the global doc has widgets with joins of type X"
* Go get all of those things
* Lather, rinse, repeat for things the widgets join with, which have
  join widgets of their own
* Say "oh hey, the global doc has widgets with joins of type Y"
* Go get all of those things

* Fetch the page
* Say "oh hey, the page has widgets with joins of type X"
* Go get all of those things...

What can we do about it?

## The parallel strategy

"Widgets may not depend on the order in which other widgets are loaded.
So don't wait, just hit the server with all of the joins in parallel."

It is not clear that this causes any real problems since the mongo driver
will apparently queue the queries and we're not talking about thousands.

What is less clear is whether it will
wait to send query 2 until query 1 is answered. It would be much better
if it sent them both and the server responded to them in series without
latency to receive them.

## The breadth-first strategy

We already accumulate the widget loads of a given type from a given
starting point and do them with one query in most cases. Do this more.
Figure out how to phase it so the queries happen when we're done
with a phase.

## The join strategy

Leverage newer mongo's join capability. This requires that mongodb
be able to figure out what joins with what. That requires that
we avoid "spelunking" through nested structures and instead maintain
a "joinDocIds" array. This way the server does the work without
latency even if the delay between node and mongo is significant.

It's not clear if this can work with reverse joins. We might
want to denormalize reverse joins.

# The widgets problem

Ordinary joins are limited in the following way: we carry out
joins that are in the schema for the docs you're fetching. We
don't carry out any joins beyond that unless specificaly requested.

Widgets blow this paradigm up, causing infinite loops. Widget
loaders don't know how far from the original find() call they are.

Widget loaders are fired by a cursor filter. That filter
invokes loaders, which make more find() calls. What if it
passed `areas: false` to those find() calls by default?

Right now the `areas` filter supports:

areas: false
areas: true
areas: [ 'thumbnail', 'body' ]

This isn't enough because `body` could bring in lots of
widget types carrying out lots of joins.

... The when-to-stop problem is hard. I need to talk through
this with more people.

* Home page fetched
* Has person widget
* Person widget fetches person
* Person joins with projects
* Projects have person widgets
* Which fetch person...

How do I break this chain? We already introduced a way: the
`projection` option to any join widget. Use of that is already
avoiding the fetch of projects associated with the person.

So maybe this isn't my biggest problem after all. Maybe
I just need a way to effectively track down recursions.
How would I find a missing `projection`? What do I need
to pass along to trace that?

* Home page fetched: "page"
* Person widget fetches person: "page:home,widget:person"
* Person joins projects: 

"pages -> widget:person -> join:projects -> widget:person -> ..."

Where do I carry this info? 

pageServe: find().trace('page')
  people.load(req, widgets, cursor.get('trace'))
    trace = trace.concat([ 'widget:people' ])
    projects.find().trace(cursor.get('trace')) -> appends "projects"


